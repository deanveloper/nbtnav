package nbt

import (
	"bytes"
	"reflect"
	"testing"
)

var simpleTests = []struct {
	name string
	in   []byte
	out  *Compound
	err  error
}{
	{
		"invalidTop",
		// Root tag isn't Compound
		[]byte{
			0x01, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74, 0x11,
		},
		nil,
		ErrInvalidTop,
	},
	{
		"compound byte",
		[]byte{
			0x0a, 0x00, 0x00, 0x01, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x11, 0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": &Int8{0x11},
			},
		},
		nil,
	},
	{
		"compound short",
		[]byte{
			0x0a, 0x00, 0x00, 0x02, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x11, 0x22, 0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": &Int16{0x1122},
			},
		},
		nil,
	},
	{
		"compound int",
		[]byte{
			0x0a, 0x00, 0x00, 0x03, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x11, 0x22, 0x33, 0x44, 0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": &Int32{0x11223344},
			},
		},
		nil,
	},
	{
		"compound long",
		[]byte{
			0x0a, 0x00, 0x00, 0x04, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": &Int64{0x1122334455667788},
			},
		},
		nil,
	},
	{
		"compound float",
		[]byte{
			0x0a, 0x00, 0x00, 0x05, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x46, 0x40, 0xe6, 0xb7, 0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": &Float32{12345.6789},
			},
		},
		nil,
	},
	{
		"compound double",
		[]byte{
			0x0a, 0x00, 0x00, 0x06, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x40, 0xc8, 0x1c, 0xd6, 0xe6, 0x31, 0xf8, 0xa1, 0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": &Float64{12345.6789},
			},
		},
		nil,
	},
	{
		"compound byte array",
		[]byte{
			0x0a, 0x00, 0x00, 0x07, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x00, 0x00, 0x00, 0x04, 0x13, 0x37, 0x11, 0x22, 0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": NewByteArray([]int8{0x13, 0x37, 0x11, 0x22}),
			},
		},
		nil,
	},
	{
		"compound string",
		[]byte{
			0x0a, 0x00, 0x00, 0x08, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x00, 0x06, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x6f, 0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": &String{"minero"},
			},
		},
		nil,
	},
	{
		"compound list",
		[]byte{
			0x0a, 0x00, 0x00, 0x09, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x12, 0x00, 0x34, 0x00,
			0x56, 0x00, 0x78, 0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": &List{
					Typ: TagShort,
					Value: []Tag{
						&Int16{0x12}, &Int16{0x34}, &Int16{0x56}, &Int16{0x78},
					},
				},
			},
		},
		nil,
	},
	{
		"compound compound",
		[]byte{
			0x0a, 0x00, 0x00, 0x0a, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x04, 0x00, 0x04, 0x6c, 0x6f, 0x6e, 0x67, 0x01, 0x12, 0x23,
			0x34, 0x45, 0x56, 0x67, 0x78, 0x00, 0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": &Compound{
					Name: "test",
					Value: map[string]Tag{
						"long": &Int64{0x0112233445566778},
					},
				},
			},
		},
		nil,
	},
	{
		"compound int array",
		[]byte{
			0x0a, 0x00, 0x00, 0x0b, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
			0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00,
			0x00, 0x22, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x44,
			0x00,
		},
		&Compound{
			Name: "",
			Value: map[string]Tag{
				"test": NewIntArray([]int32{0x11, 0x22, 0x33, 0x44}),
			},
		},
		nil,
	},
}

func TestRead(t *testing.T) {
	for _, test := range simpleTests {
		// Read byte blob
		r := bytes.NewBuffer(test.in)
		c, err := Read(r)

		// Expected errors?
		if test.err != err {
			t.Logf("Error: %v", err)
			t.Logf("Expected: %v", test.err)
			t.Fatalf("%s: Errors don't match.", test.name)
		}

		// Expected compound?
		if !reflect.DeepEqual(c, test.out) {
			t.Logf("Compound: %#v (%#v)", c, c.Value["test"])
			t.Logf("Expected: %#v (%#v)", test.out, test.out.Value["test"])

			t.Fatalf("%s: Compounds don't match.", test.name)
		}

		t.Logf("%s test passed.", test.name)

		r.Reset()
	}
}

func TestWrite(t *testing.T) {
	var w bytes.Buffer

	// Skip first test
	for _, test := range simpleTests[1:] {
		// Write compound
		err := Write(&w, test.out)

		// Expected errors?
		if test.err != err {
			t.Fatalf("%s: Errors don't match.", test.name)
		}

		// Expected compound?
		if !bytes.Equal(w.Bytes(), test.in) {
			t.Logf("Compound: % x", w.Bytes())
			t.Logf("Expected: % x", test.in)
			t.Fatalf("%s: Compounds don't match.", test.name)
		}

		w.Reset()
	}
}
